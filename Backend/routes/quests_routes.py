import math
from flask import Blueprint
import openai
import json
import random
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required
from models import Quest
from navigation_routes import routes_with_landmarks

# Set up post blueprint at "/api/quests"
quests_bp = Blueprint('quests', __name__, url_prefix="/api/quests")

@quests_bp.route('/generateFromRoute', methods=['POST'])
def generate_quests_from_route():
    """
    Expects a JSON payload containing:
    {
       "start_location": "Location A",
       "end_location": "Location B",
       "route_summary": "Summary text...",
       "route_steps": "Step by step directions...",
       "total_distance": "120 miles",
       "total_duration": "2 hours",
       "landmarks": [
           {
             "name": "Landmark 1",
             "type": "historical",
             "rating": 4.5,
             "latitude": 40.7128,
             "longitude": -74.0060
           },
           {
             "name": "Landmark 2",
             "type": "restaurant",
             "rating": 4.0
           },
           ... more landmarks ...
       ]
    }

    For each landmark, a quest is generated by calling ChatGPT.
    Returns the list of created quests.
    """
    if request.headers.get("Content-Type") != "application/json":
        return jsonify({"error": "Content-Type must be application/json", "success": False, "status": 400})
    
    data = request.get_json()
    required_fields = ["start_location", "end_location", "route_summary", "route_steps", "total_distance", "total_duration", "landmarks"]

    for field in required_fields:
        if field not in data:
            return jsonify({"error": f"Missing required field: {field}", "success": False, "status": 400})
    
    # Extract route information and landmarks from the payload
    landmarks = data.get("landmarks")

    quests_created = []
    
    for landmark in landmarks:
        # Generate quest details using ChatGPT
        quest_details = generate_quest_via_chatgpt(landmark, route_info)

        try:
            quest = Quest(
                name=quest_details.get("name"),
                description=quest_details.get("description"),
                landmark=landmark.get("name"),
                reward=quest_details.get("reward")
            )
            quest.save()
            quests_created.append(quest.to_json())
        except Exception as e:
            return jsonify({"error": f"Error saving quest: {str(e)}", "success": False, "status": 500})
    return jsonify({
        "message": "Quests generated successfully",
        "quests": quests_created,
        "success": True,
        "status": 201
    })





def generate_quest_via_chatgpt(landmark, route_info):
    """
    Build a prompt using landmark details and route info and generate a quest.
    Returns a dictionary with keys: "name", "description", "reward".
    """
    # Define possible challenges based on landmark type
    challenges = {
        "museum": [
            "Take a guided tour.",
            "Find a piece of art that you like the most, and take a picture with it.",
            "Collect a museum brochure and find one fact that most visitors don’t know about the exhibits.",
            "Spend at least 30 minutes at the museum, and try to describe your favorite artwork or artifact to someone else."
        ],
        "restaurant": [
            "Order a signature dish from the restaurant and take a picture of your meal before eating.",
            "Talk to the staff about the most popular dish and try it out.",
            "Leave a positive review or recommendation about the restaurant on a food review app or social media.",
            "Try a dish you’ve never had before and rate it from 1 to 10."
        ],
        "university": [
            "Buy a school souvenir or piece of merchandise like a T-shirt or mug from the campus store.",
            "Take a picture at the main campus entrance with a campus map or university flag.",
            "Visit the campus library and find an interesting book or historical document to look at.",
            "Sit on the campus quad and do something productive (like reading or journaling) for 15 minutes."
        ],
        "shopping mall": [
            "Buy something you’ve never bought before from a store you’ve never visited.",
            "Find a sale and make a purchase from a store that has something you’ve been eyeing.",
            "Take a photo of your favorite store in the mall and show it to a friend to ask if they’ve been there.",
            "Spend 15 minutes walking around the mall without buying anything and just window shop."
        ],
        "historical landmark": [
            "Take a selfie with the landmark in the background.",
            "Read a historical fact about the landmark and explain it to someone visiting with you.",
            "Find the oldest part of the landmark and take a close-up photo of it.",
            "Look for a plaque or a sign near the landmark that gives historical context and take a photo of it."
        ]
    }

    # Get the landmark type and challenges
    landmark_type = landmark.get('type', '').lower()
    
    # Ensure we have challenges for this landmark type, or pick the fallback challenge
    if landmark_type in challenges:
        selected_challenges = challenges[landmark_type]
    else:
        selected_challenges = ["Explore and take pictures!"]  # Fallback only if no challenges exist
    
    # Pick a single random challenge from the available ones (just one, not multiple)
    challenge = random.choice(selected_challenges)
    
    # Return quest details
    quest_data = {
        "name": f"Quest at {landmark.get('name')}",
        "description": f"Visit {landmark.get('name')} and complete the challenge: {challenge}",
        "reward": math.floor(random.randint(100, 300) / 10) * 10  # Random reward, you can adjust this as needed
    }
    
    return quest_data



